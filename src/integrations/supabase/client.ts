
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://whazqibezrvxzkqwzsts.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6IndoYXpxaWJlenJ2eHprcXd6c3RzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIwMDUxODQsImV4cCI6MjA1NzU4MTE4NH0.Z9XyzKIWIjGHMvl97QIOFcPMm4GXqTjUirEDbal-eUc";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Authentication Functions
export const getSession = async () => {
  const { data, error } = await supabase.auth.getSession();
  if (error) {
    console.error('Error getting session:', error);
    return null;
  }
  return data?.session;
};

export const getCurrentUser = async () => {
  const { data, error } = await supabase.auth.getUser();
  if (error) {
    console.error('Error getting user:', error);
    return null;
  }
  return data?.user;
};

export const signUpWithEmail = async (email: string, password: string, userData: any) => {
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: userData
    }
  });
  
  if (error) {
    console.error('Error signing up:', error);
    return { error };
  }
  
  return { data };
};

export const signInWithEmail = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password
  });
  
  if (error) {
    console.error('Error signing in:', error);
    return { error };
  }
  
  return { data };
};

export const signOut = async () => {
  const { error } = await supabase.auth.signOut();
  if (error) {
    console.error('Error signing out:', error);
    return { error };
  }
  
  return { success: true };
};

// Ride Data Functions
export const createRideRequest = async (rideData: Database['public']['Tables']['ride_requests']['Insert']) => {
  const { data, error } = await supabase
    .from('ride_requests')
    .insert(rideData)
    .select()
    .single();
  
  if (error) {
    console.error('Error creating ride request:', error);
    return { error };
  }
  
  return { data };
};

export const getRideRequests = async (userId: string, isDriver: boolean = false) => {
  let query = supabase
    .from('ride_requests')
    .select('*, drivers(*)');
    
  if (isDriver) {
    query = query.eq('driver_id', userId);
  } else {
    query = query.eq('rider_id', userId);
  }
  
  const { data, error } = await query;
  
  if (error) {
    console.error('Error fetching ride requests:', error);
    return { error };
  }
  
  return { data };
};

export const updateRideStatus = async (rideId: string, status: Database['public']['Enums']['ride_status'], updates: any = {}) => {
  const { data, error } = await supabase
    .from('ride_requests')
    .update({ status, ...updates })
    .eq('id', rideId)
    .select()
    .single();
  
  if (error) {
    console.error('Error updating ride status:', error);
    return { error };
  }
  
  return { data };
};

// Driver Location Tracking
export const updateDriverLocation = async (driverId: string, latitude: number, longitude: number, heading: number | null = null, isAvailable: boolean = true) => {
  const { data, error } = await supabase
    .from('driver_locations')
    .upsert({
      driver_id: driverId,
      latitude,
      longitude,
      heading,
      is_available: isAvailable,
      timestamp: new Date().toISOString()
    })
    .select()
    .single();
  
  if (error) {
    console.error('Error updating driver location:', error);
    return { error };
  }
  
  return { data };
};

export const getNearbyDrivers = async (latitude: number, longitude: number, radiusKm: number = 5) => {
  const { data, error } = await supabase.rpc('calculate_distance', {
    lat1: latitude,
    lon1: longitude,
    lat2: 0, // These values will be replaced by driver locations
    lon2: 0  // These values will be replaced by driver locations
  });
  
  if (error) {
    console.error('Error calculating distance:', error);
    return { error };
  }
  
  const { data: drivers, error: driversError } = await supabase
    .from('driver_locations')
    .select('*, drivers(*)')
    .eq('is_available', true);
  
  if (driversError) {
    console.error('Error fetching drivers:', driversError);
    return { error: driversError };
  }
  
  // Filter drivers within radius
  const nearbyDrivers = drivers?.filter(driver => {
    const distance = calculateDistance(
      latitude, 
      longitude, 
      driver.latitude, 
      driver.longitude
    );
    return distance <= radiusKm;
  });
  
  return { data: nearbyDrivers };
};

// Helper function to calculate distance between two points
const calculateDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {
  const R = 6371; // Radius of the earth in km
  const dLat = deg2rad(lat2 - lat1);
  const dLon = deg2rad(lon2 - lon1);
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2); 
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  const distance = R * c; // Distance in km
  return distance;
};

const deg2rad = (deg: number): number => {
  return deg * (Math.PI/180);
};

// Surge Pricing Prediction
export const getSurgePredictions = async (latitude: number, longitude: number) => {
  const { data, error } = await supabase
    .from('surge_predictions')
    .select('*')
    .lte('latitude', latitude + 0.05)
    .gte('latitude', latitude - 0.05)
    .lte('longitude', longitude + 0.05)
    .gte('longitude', longitude - 0.05)
    .gte('valid_until', new Date().toISOString());
  
  if (error) {
    console.error('Error fetching surge predictions:', error);
    return { error };
  }
  
  return { data };
};

// Real-time subscriptions
export const subscribeToDriverLocations = (callback: (payload: any) => void) => {
  return supabase
    .channel('public:driver_locations')
    .on('postgres_changes', { 
      event: '*', 
      schema: 'public', 
      table: 'driver_locations' 
    }, callback)
    .subscribe();
};

export const subscribeToRideRequests = (userId: string, isDriver: boolean, callback: (payload: any) => void) => {
  const column = isDriver ? 'driver_id' : 'rider_id';
  
  return supabase
    .channel(`public:ride_requests:${column}:${userId}`)
    .on('postgres_changes', { 
      event: '*', 
      schema: 'public', 
      table: 'ride_requests',
      filter: `${column}=eq.${userId}`
    }, callback)
    .subscribe();
};

export const subscribeToSurgePredictions = (latitude: number, longitude: number, callback: (payload: any) => void) => {
  return supabase
    .channel('public:surge_predictions')
    .on('postgres_changes', { 
      event: '*', 
      schema: 'public', 
      table: 'surge_predictions' 
    }, callback)
    .subscribe();
};
